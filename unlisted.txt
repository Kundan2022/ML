DFS================>>>>>>>>>>>>>>.
graph = {
  'A' : ['B','C'],
  'B' : ['D', 'E'],
  'D' : ['G','H'],
  'E' : [],
  'G' : ['N'],
  'H' : ['J','K'],
  'J' : ['N','O'],
  'K' : ['P'],
  'N' : ['G'],
  'O' : [],
  'P' : ['Q'],
  'C' : ['F'],
  'F' : ['I'],
  'I' : ['L','M'],
  'L' : ['Q'],
  'M' : [],
  'Q' : ['P']
}
stack = []
visited = []
goal=''

def dfs(graph, source):
    stack.append(source)
    visited.append(source)
    while stack:
        vertex = stack.pop()
        print (vertex, end = " ")
        if goal==vertex:
            print ("\nGoal reached ",vertex)
            break
        graph[vertex].reverse()
        for u in graph[vertex]:
            if u not in visited:
                stack.append(u)
                visited.append(u)


goal=input("Enter a goal:")
dfs(graph, "A")
if goal not in visited:
    print("\nGoal not found")



A*========================>>>>>>>>>>
def heuristic(n):
    H_dist = {
        'A': 380,
        'B': 374,
        'C': 366,
        'D': 253,
        'E': 329,
        'F': 244,
        'G': 241,
        'H': 242,
        'I': 193,
        'J': 176,
        'K': 160,
        'L': 100,
        'M': 0,
        'N': 80,
        'O': 151,
        'P': 161,
        'Q': 199,
        'R': 236,
        'S': 234,
        'T': 77,

        
    }
    return H_dist[n]

Graph_nodes = {
    'A': [('B', 71), ('D', 151)],    
    'B': [('C', 76), ('A', 71)],
    'C': [('D', 140),('E', 118),('B',75)],
    'D': [('C', 140),('J', 99),('I',80)],
    'E': [('C', 118),('F' ,111)],
    'F': [('E', 111),('G', 70)],
    'G': [('F', 70),('H',75)],
    'H': [('G',75), ('K',120)],
    'I': [('L',97), ('K',146)],
    'J': [('D',99), ('M',211)],
    'K': [('I',146),('L',138), ('H',120)],
    'L': [('I',97), ('K',138), ('M',101)],
    'M': [('J',211), ('L',101), ('T',90), ('N',85)],
    'N': [('M',85), ('O',98), ('Q',142)],
    'O': [('N',98), ('P',86)],
    'P': [('O',86)],
    'Q': [('R',92), ('N',142)],
    'R': [('S',87), ('Q',92)],
    'S': [('R',87)],
    'T': [('M',90)]
}
def get_neighbors(v):
    if v in Graph_nodes:
        return Graph_nodes[v]
    else:
        return None
    
    
    
def aStarAlgo(start_node, stop_node):
    if start_node not in Graph_nodes:
        print('Path does not exist!')
        return
    
    open_set = set(start_node)
    closed_set = set()
    g = {}              
    parents = {}       
    g[start_node] = 0
    parents[start_node] = start_node
    
    while len(open_set) > 0:
        n = None
        
        for v in open_set:
            if n==None or g[v] + heuristic(v) < g[n] + heuristic(n):
                n = v
                
        if n == stop_node:
            path = []
            while parents[n] != n:
                path.append(n)
                n = parents[n]
            path.append(start_node)
            path.reverse()
            print('Minimum Path found: ')#.format(path))
            return path        
        
        
        if n != stop_node or Graph_nodes[n] != None :
            for (m, weight) in get_neighbors(n):
                if m not in open_set and m not in closed_set:
                    open_set.add(m)
                    parents[m] = n
                    g[m] = g[n] + weight
                else:
                    if g[m] > g[n] + weight:
                        g[m] = g[n] + weight
                        parents[m] = n
                        if m in closed_set:
                            closed_set.remove(m)
                            open_set.add(m)

        open_set.remove(n)
        closed_set.add(n)
        
start=input("Enter a start state: ")
#goal=input("Enter a goal state: ")
aStarAlgo(start,"M")




Graph======================>>>>>>>>>>
colors = ['Red', 'Blue', 'Green', ]

G = ['A', 'B', 'C', 'D']

neighbors = {
         'A' : ['B', 'C'],
         'B' : ['A', 'C', 'D'],
         'C' : ['A', 'B', 'D'],
         'D' : ['B', 'C']
      }
colors_of_states = {}

def promising(state, color):
    for neighbor in neighbors[state]:#.get(state): 
        color_of_neighbor = colors_of_states.get(neighbor)
        if color_of_neighbor == color:
            return False

    return True

def get_color_for_state(state):
    for color in colors:
        if promising(state, color):
            return color

def main():
    for state in G:
        colors_of_states[state] = get_color_for_state(state)

    print(colors_of_states)


main()





water======================>>>>>>>>>>>>>>
def jug(jug1,jug2,goal,n,m,l):
    while jug1!=goal and jug2!=goal:
        if jug2==0:
            jug2=m
            l.append((jug1,jug2))
        jug1+=jug2
        if jug1>n:
            jug2=jug1-n
            jug1=n
            l.append((jug1,jug2))
        else:
            jug2=0
            l.append((jug1,jug2))
        if jug1>=n:
            if jug1!=goal:
                jug1=0
            else:
                jug2=0
            l.append((jug1,jug2))

            
def main():
    global l1
    l1=[]
    global l2
    l2=[]
    c1=int(input("Enter jug 1 capacity: "))
    c2=int(input("Enter jug 2 capacity: "))
    goal=int(input("Enter goal capacity: "))
    if c1%2==0 and c2%2==0 and goal%2!=0:
        print("Case not possible")    
    elif goal>max([c1,c2]):
        print("Limit Exceeded")
    else: 
        jug1=0
        jug2=0
        jug(jug1,jug2,goal,c1,c2,l1)
        global parent
        parent=(0,0)
        jug(jug2,jug1,goal,c2,c1,l2)
        if len(l1)<=len(l2):
            [print(x) for x in l1]
        else:
            [print(x[::-1]) for x in l2]
main()





NQueen===================>>>>>>>>>
print ("Enter the number of queens")
N = int(input())
board = [[0]*N for _ in range(N)]
def attack(i, j):
    for k in range(0,N):
        if board[i][k]==1 or board[k][j]==1:
            return True
    for k in range(0,N):
        for l in range(0,N):
            if (k+l==i+j) or (k-l==i-j):
                if board[k][l]==1:
                    return True
    return False
def N_queens(n):
    if n==0:
        return True
    for i in range(0,N):
        for j in range(0,N):
            if (not(attack(i,j))) and (board[i][j]!=1):
                board[i][j] = 1
                if N_queens(n-1)==True:
                    return True
                board[i][j] = 0
    return False
N_queens(N)
for i in board:
    print (i)









